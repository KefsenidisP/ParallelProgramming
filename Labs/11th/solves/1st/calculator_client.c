/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

/*
 * Did not change much from the 9th lab. The code is obviously smaller
 * follows the same loogic wwiith the exception, that it does not
 * need to wait for the server to accept connections
 */

#include "calculator.h"

#define MSG_LINE 24 // Length of printeble messsages
#define OP_LEN 21 // Max length of an operand
#define USER_MSG (OP_LEN * 2) + 1 // The size of the user input
#define DELIMETER " " // Second argument of the strtok function

// Error codes
#define OK 0
#define ERROR 1
#define EXIT 2

// Below are the protocal orders
#define CMD_EXIT '!'
#define CMD_ADD '+'
#define CMD_REDUCE '-'
#define CMD_DIV '/'
#define CMD_MUL '*'

// Returns 0 if the input is ok. Also returns the request message and the CMD_'ACTION' code 
int check_input(char * line, char * operation, request_t * request)
{
    int operand_cnt = 0;
    int operator_found = 0;
    char * tmp;

    // The operator must be at the beginning of the line
    *operation = line[0];
    if (*operation == '!')
        return 0;
    else if (*operation != '*' && *operation != '-' &&
            *operation != '/' && *operation != '+')
    {
        printf("Wrong operator %c!\n", *operation);
        return 1;
    }

    // Cut the inputed string and parse to a request type
    tmp = strtok(line, DELIMETER); // The first one is the operator, which has already been parsed
    while (1)
    {
        tmp = strtok(NULL, DELIMETER);

        if (tmp == NULL)
            break;

        operand_cnt++;

        // Left operand
        if (operand_cnt == 1)
            request->val1 = strtod(tmp, NULL);
        else if (operand_cnt == 2) // Right operand
            request->val2 = strtod(tmp, NULL);
    }

    if (operand_cnt != 2)
    {
        printf("Two operands needed only %d provided!\n", operand_cnt);
        return 2;
    }

    return 0;
}

// Get from user and check format. Also the operation to be performed by the user
// and the request to send
char recv_from_user(char * line, request_t * request)
{
    char operation; // +, -, /, * or !

    while (1)
    {
        // Receive input
        puts("Type: <operation> <operand1> <operand2>, or just type \'!\' to exit");
        puts("Where operation is +, -, / or *");
        puts("and <operand> a random value");
        
        fgets(line, USER_MSG, stdin);
        
        // Check the input
        if(!check_input(line, &operation, request))
            break;
    }

    return operation;
}

// Call a remote procedure according to the operation type and return the reply
reply_t call_procedure(request_t request, int operation, CLIENT * clnt)
{
    reply_t * reply;

    switch (operation)
    {
        case CMD_EXIT:
            puts("Now exiting...");
            exit(0);
        case CMD_ADD:
            puts("Calling add...");
            reply = add_1(&request, clnt);
            return *reply;
        case CMD_DIV:
            puts("Calling divide...");
            reply = divide_1(&request, clnt);
            return *reply;
        case CMD_MUL:
            puts("Calling multiply...");
            reply = multiply_1(&request, clnt);
            return *reply;
        case CMD_REDUCE:
            puts("Calling reduce...");
            reply = deduct_1(&request, clnt);
            return *reply;
        default:
            puts("This should never happen...");
            exit(1337);
    }
}

// Make the reply type a string and check for errors
int parse_from_reply(reply_t reply, char * str)
{
    sprintf(str, "%.16f", reply.result);
    return reply.code;
}

void
calculator(char *host)
{
	CLIENT *clnt;
    char input[USER_MSG]; // This is to resolve an error with strtok function
    char operation;
    request_t request;
    reply_t reply;
    char result_str[MSG_LINE];

#ifndef	DEBUG
    // Connect to the host server, from to call remote procedures
	clnt = clnt_create (host, CALCULATOR, CALCULATOR_V_1, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

    /* The implementation goes here */
    while (1)
    {
        // Ask for used input and parse it to reqeust
        operation = recv_from_user(input, &request);
        // Call remote method from server
        reply = call_procedure(request, operation, clnt);
        // Parse the reply to printable and check for error
        if (parse_from_reply(reply, result_str))
        {
            puts("Performed division with 0!");
            continue;
        }
        // Show message to user
        printf("The result is %s\n", result_str);
    }

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}

void
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) 
    {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	
    host = argv[1];
	calculator (host);
    
    exit (0);
}

/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calc_pi.h"
#include <pthread.h>

#define OK 0
#define ERROR 1

struct calced_pis {
    int iters;
    double pi;
    struct calced_pis * next;
};

// The global array for saving pis
struct calced_pis * pi_list;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

static double
f ( double a )
{
    return (4.0 / (1.0 + a * a));
}

static void 
add_pi_elm(struct calced_pis * pi_list_elm)
{
    struct calced_pis * tmp;

    puts("Adding in list...");

    // Initialize the pi_list if it is nuull
    if (pi_list == NULL)
        pi_list = (struct calced_pis *) calloc(1, sizeof(struct calced_pis));

    // Insert new element, only if a copy of it does not exist
    for (tmp = pi_list; ; tmp = tmp->next)
    {
        if (tmp->iters == pi_list_elm->iters)
            return;

        if (tmp->next == NULL)
            break;
    }

    tmp->next = pi_list_elm;
}

// Returns 1 if found and 0 if not
static int 
search_in_pi_list(int iters, reply_t * reply)
{
    struct calced_pis * pi_list_elm;
    
    // Initialize the pi_list if it is nuull
    if (pi_list == NULL)
        pi_list = (struct calced_pis *) calloc(1, sizeof(struct calced_pis));

    // Iterate through the pi_list list
    for (pi_list_elm = pi_list; ; pi_list_elm = pi_list_elm->next)
    {
        if (pi_list_elm->iters == iters)
        {
            reply->code = OK;
            reply->pi = pi_list_elm->pi;

            puts("Found in list...");

            return 1;
        }

        if (pi_list_elm->next == NULL)
            break;
    }

    // The pi was never calculated
    reply->code = OK;

    return 0;
}

reply_t *
calc_pi_1_svc(request_t *argp, struct svc_req *rqstp)
{
	static reply_t reply; // Saved on heap
    double x = 0.0;
    double step = 1.0 / (double) argp->iters;
    double sum = 0.0;
    double pi = 0.0;
    struct calced_pis * pi_list_elm;

    puts("New connection...");

    // Recheck if the iterations number is neagtive
    if (argp->iters <= 0)
    {
        reply.code = ERROR;
        return &reply;
    }

    // Before doing anything, first search if the pi was already calculated
    if (search_in_pi_list(argp->iters, &reply))
        return &reply;

    // Initialize the pi element pointer
    pi_list_elm = (struct calced_pis *) malloc(sizeof(struct calced_pis));

    // Calculate the sum
    for (int i = 1; i <= argp->iters; ++i)
    {
    	x = step * ((double)i - 0.5);
        sum += f(x);
    }

    // Calculate pi
    pi = step * sum;

    // Assign values to the element of the pi list
    pi_list_elm->iters = argp->iters;
    pi_list_elm->pi = pi;
    pi_list_elm->next = NULL;

    // Insert the new element in the list
    pthread_mutex_lock(&mutex);
    add_pi_elm(pi_list_elm);
    pthread_mutex_unlock(&mutex);

    reply.code = OK;
    reply.pi = pi;

	return &reply;
}

/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calc_pi.h"
#include <pthread.h>


#define GROUP_NUM 8
#define MAX_ITERS 1000000

struct thread_gorups_t {
    int assigned; // 0 if thread group with id does not exist
    int threads_running; // Number of running trheads
    double sum; // The sum that  has been calculated by this group
};

// 1 if active and 0 if not
struct thread_gorups_t groups[GROUP_NUM];

pthread_mutex_t assign_task_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t get_sum_mutex = PTHREAD_MUTEX_INITIALIZER;

// Assign to each process that connects an id.
groupid_t *
get_groupid_1_svc(void *argp, struct svc_req *rqstp)
{
	static groupid_t result;
    int i;

    for (i = 0; i < GROUP_NUM; ++i)
        if (!(groups[i].assigned))
        {
            groups[i].assigned = 1;
            groups[i].sum = 0.0;
            groups[i].threads_running = 0;
            break;        
        }

    result = ((i == GROUP_NUM) ? (-1) : (i));

	return &result;
}

worker_args_t *
assign_to_task_1_svc(master_args_t *argp, struct svc_req *rqstp)
{
    pthread_mutex_lock(&assign_task_mutex);

	static worker_args_t  result;

    // This function assigns workload to newly created threads
    result.rank = groups[argp->groupid].threads_running;
    
    (groups[argp->groupid].threads_running)++;

    result.iters_max = MAX_ITERS;
    result.thread_iters = MAX_ITERS / (argp->thread_num);
    pthread_mutex_unlock(&assign_task_mutex);
    printf("%d, %d\n", result.thread_iters, groups[argp->groupid].threads_running);

	return &result;
}

int *
send_sum_1_svc(master_args_t *argp, struct svc_req *rqstp)
{
    // The return value is not needed
	static int result = 1;

    // It is actually a reduce performed by the master
    pthread_mutex_lock(&get_sum_mutex);
    groups[argp->groupid].sum += argp->sum;
    pthread_mutex_unlock(&get_sum_mutex);

	return &result;
}

int *
mark_as_finished_1_svc(groupid_t *argp, struct svc_req *rqstp)
{
    // Not needed return value
	static int result;
    double pi;

    // The master calculates the pi
    pi = groups[*argp].sum * (1.0 / MAX_ITERS);
    printf("Pi from group %d is %.16f\n", *argp, pi);

    groups[*argp].assigned = 0;

	return &result;
}
